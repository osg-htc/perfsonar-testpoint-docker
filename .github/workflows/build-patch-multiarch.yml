name: Build and push patched perfSONAR (true multi-arch)

"on":
  workflow_dispatch:
    inputs:
      upstream_tag:
        description: "Upstream tag (e.g., v5.2.3 or 5.2.3). Required for reproducible builds."
        required: true
        default: "v5.2.3"
      variant:
        description: "Base variant to derive from (systemd|supervisord)"
        required: false
        default: "systemd"
      force_version:
        description: "Force final published version tag (overrides normalization)"
        required: false
        default: ""
      env_tag:
        description: "Optional additional tag to also publish (e.g., production, test, or none)"
        required: false
        default: "none"

env:
  REGISTRY: hub.opensciencegrid.org
  IMAGE_REPO: osg-htc/perfsonar-testpoint
  UPSTREAM_IMAGE_BASE: ghcr.io/perfsonar/testpoint

concurrency:
  group: patched-multiarch-${{ github.ref }}
  cancel-in-progress: false

jobs:
  # Resolve upstream tag and final published version; verify upstream image exists.
  resolve:
    runs-on: ubuntu-latest
    outputs:
      upstream_image: ${{ steps.resolve.outputs.upstream_image }}
      final_version: ${{ steps.resolve.outputs.final_version }}
      variant: ${{ steps.resolve.outputs.variant }}
    steps:
      - name: Resolve upstream image tag and final version
        id: resolve
        shell: bash
        run: |
          set -euo pipefail
          REQ="${{ github.event.inputs.upstream_tag }}"
          VARIANT="${{ github.event.inputs.variant }}"
          FORCE="${{ github.event.inputs.force_version }}"

          # Normalize requested tag (accept 5.2.3 or v5.2.3)
          if [[ "$REQ" =~ ^v ]]; then
            BASE="$REQ"
          else
            BASE="v${REQ}"
          fi

          # Map to upstream GHCR tag (systemd adds -systemd suffix)
          if [ "$VARIANT" = "systemd" ]; then
            case "$BASE" in
              *-systemd) GHCR_TAG="$BASE" ;;
              *) GHCR_TAG="${BASE}-systemd" ;;
            esac
          elif [ "$VARIANT" = "supervisord" ]; then
            # No suffix for supervisord
            GHCR_TAG="$BASE"
          else
            echo "Invalid variant '$VARIANT' (must be systemd or supervisord)"; exit 1
          fi

          UPSTREAM_IMAGE="${UPSTREAM_IMAGE_BASE}:${GHCR_TAG}"
          echo "Upstream image candidate: ${UPSTREAM_IMAGE}"

          # Verify the upstream manifest exists
          if ! docker buildx imagetools inspect "${UPSTREAM_IMAGE}" >/dev/null 2>&1; then
            echo "ERROR: Upstream image '${UPSTREAM_IMAGE}' not found on GHCR." >&2
            echo "Hint: ensure the tag exists upstream (e.g., v5.2.3-systemd)" >&2
            exit 1
          fi

          # Compute final published version
          if [ -n "$FORCE" ]; then
            FINAL="$FORCE"
          else
            # Derive from REQ (strip leading 'v')
            N="${REQ#v}"
            if [ "$VARIANT" = "systemd" ] && [[ ! "$N" =~ -systemd$ ]]; then
              N="${N}-systemd"
            fi
            FINAL="$N"
          fi

          echo "Resolved upstream image: ${UPSTREAM_IMAGE}"
          echo "Final published version: ${FINAL}"
          echo "Variant: ${VARIANT}"

          echo "upstream_image=${UPSTREAM_IMAGE}" >> "$GITHUB_OUTPUT"
          echo "final_version=${FINAL}" >> "$GITHUB_OUTPUT"
          echo "variant=${VARIANT}" >> "$GITHUB_OUTPUT"

  # Build patch layer per-architecture, from the exact per-arch digest of the upstream image.
  build-per-arch:
    needs: resolve
    strategy:
      matrix:
        include:
          - platform: linux/amd64
            arch: amd64
            runs_on: ubuntu-latest
          - platform: linux/arm64
            arch: arm64
            runs_on: ubuntu-24.04-arm
    runs-on: ${{ matrix.runs_on }}
    steps:
      - name: Checkout this repo
        uses: actions/checkout@v4

      - name: Ensure tools (jq, skopeo) are installed
        shell: bash
        run: |
          set -e
          sudo apt-get update -y
          sudo apt-get install -y jq skopeo

      - name: Verify patching files exist
        shell: bash
        run: |
          [ -f Dockerfile.patched ] || { echo "Missing Dockerfile.patched"; exit 1; }
          [ -f patches/osg-restrictions.conf ] || { echo "Missing patches/osg-restrictions.conf"; exit 1; }

      - name: Log into Harbor (target registry)
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.OSG_HARBOR_ROBOT_USER }}
          password: ${{ secrets.OSG_HARBOR_ROBOT_PASSWORD }}

      - name: Set up Buildx
        uses: docker/setup-buildx-action@v3

      - name: Resolve per-arch upstream digest
        id: dig
        shell: bash
        env:
          UPSTREAM_IMAGE: ${{ needs.resolve.outputs.upstream_image }}
        run: |
          set -euo pipefail
          ARCH="${{ matrix.arch }}"
          # skopeo inspect outputs JSON including per-arch manifests with their digests
          DIGEST=$(skopeo inspect "docker://${UPSTREAM_IMAGE}" \
            | jq -r --arg arch "$ARCH" '.manifests[] | select(.platform.os=="linux" and .platform.architecture==$arch) | .digest' \
            | head -1)
          if [ -z "$DIGEST" ] || [ "$DIGEST" = "null" ]; then
            echo "ERROR: Could not resolve digest for $UPSTREAM_IMAGE on arch ${ARCH}" >&2
            exit 1
          fi
          echo "digest=${DIGEST}" >> "$GITHUB_OUTPUT"
          echo "Resolved digest for ${ARCH}: ${DIGEST}"

      - name: Build and push patched image (this arch)
        shell: bash
        env:
          FINAL: ${{ needs.resolve.outputs.final_version }}
        run: |
          set -eux
          ARCH="${{ matrix.arch }}"
          PLATFORM="${{ matrix.platform }}"
          BASE_IMAGE="${{ env.UPSTREAM_IMAGE_BASE }}@${{ steps.dig.outputs.digest }}"

          EXTRA_TAGS=""
          if [ "${{ github.event.inputs.env_tag }}" != "" ] && [ "${{ github.event.inputs.env_tag }}" != "none" ]; then
            EXTRA_TAGS="-t ${REGISTRY}/${IMAGE_REPO}:${{ github.event.inputs.env_tag }}-${ARCH}"
          fi

          docker buildx build \
            --platform "${PLATFORM}" \
            --pull \
            --build-arg BASE_IMAGE="${BASE_IMAGE}" \
            -f Dockerfile.patched \
            -t "${REGISTRY}/${IMAGE_REPO}:${FINAL}-${ARCH}" \
            -t "${REGISTRY}/${IMAGE_REPO}:latest-${ARCH}" \
            ${EXTRA_TAGS} \
            --push \
            .

  # Assemble multi-arch manifest(s) from both arch-specific patched images.
  manifest:
    needs: [resolve, build-per-arch]
    runs-on: ubuntu-latest
    steps:
      - name: Log into Harbor
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.OSG_HARBOR_ROBOT_USER }}
          password: ${{ secrets.OSG_HARBOR_ROBOT_PASSWORD }}

      - name: Create multi-arch manifest for final version
        shell: bash
        env:
          FINAL: ${{ needs.resolve.outputs.final_version }}
        run: |
          set -eux
          docker buildx imagetools create \
            --tag "${REGISTRY}/${IMAGE_REPO}:${FINAL}" \
            "${REGISTRY}/${IMAGE_REPO}:${FINAL}-amd64" \
            "${REGISTRY}/${IMAGE_REPO}:${FINAL}-arm64"

      - name: Create multi-arch manifest for latest
        shell: bash
        run: |
          set -eux
          docker buildx imagetools create \
            --tag "${REGISTRY}/${IMAGE_REPO}:latest" \
            "${REGISTRY}/${IMAGE_REPO}:latest-amd64" \
            "${REGISTRY}/${IMAGE_REPO}:latest-arm64"

      - name: Create multi-arch manifest for env tag (if requested)
        if: ${{ github.event.inputs.env_tag != '' && github.event.inputs.env_tag != 'none' }}
        shell: bash
        run: |
          set -eux
          TAG='${{ github.event.inputs.env_tag }}'
          docker buildx imagetools create \
            --tag "${REGISTRY}/${IMAGE_REPO}:${TAG}" \
            "${REGISTRY}/${IMAGE_REPO}:${TAG}-amd64" \
            "${REGISTRY}/${IMAGE_REPO}:${TAG}-arm64"

      - name: Verify manifests (optional)
        shell: bash
        env:
          FINAL: ${{ needs.resolve.outputs.final_version }}
        run: |
          set -eux
          docker buildx imagetools inspect "${REGISTRY}/${IMAGE_REPO}:${FINAL}"
          docker buildx imagetools inspect "${REGISTRY}/${IMAGE_REPO}:latest"
          if [ "${{ github.event.inputs.env_tag }}" != "" ] && [ "${{ github.event.inputs.env_tag }}" != "none" ]; then
            docker buildx imagetools inspect "${REGISTRY}/${IMAGE_REPO}:${{ github.event.inputs.env_tag }}"
          fi
