name: Promote image tag(s) without rebuild (arbitrary targets)

on:
  workflow_dispatch:
    inputs:
      source_tag:
        description: "Existing source tag to promote (e.g. 5.2.3, latest)"
        required: true
        default: "latest"
      target_tag:
        description: "Primary target tag (e.g. production, staging, perfsonar-5.2.3)"
        required: true
        default: "production"
      additional_tags:
        description: "Optional extra target tags (space or comma separated)"
        required: false
        default: ""
      dry_run:
        description: "If true, do not actually copy; just show what would happen"
        required: false
        type: choice
        options:
          - "false"
          - "true"
        default: "false"
      max_retries:
        description: "Max retries for each copy (default 5)"
        required: false
        default: "5"

env:
  REGISTRY: hub.opensciencegrid.org
  IMAGE_REPO: osg-htc/perfsonar-testpoint

jobs:
  promote:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - name: Show parameters
        run: |
          echo "Source tag:         '${{ github.event.inputs.source_tag }}'"
          echo "Primary target tag: '${{ github.event.inputs.target_tag }}'"
          echo "Additional tags:    '${{ github.event.inputs.additional_tags }}'"
          echo "Dry run:            '${{ github.event.inputs.dry_run }}'"
          echo "Max retries:        '${{ github.event.inputs.max_retries }}'"

      - name: Install crane
        uses: imjasonh/setup-crane@v0.3

      - name: Install skopeo (apt)
        run: |
          set -eo pipefail
          sudo apt-get update
          sudo apt-get install -y skopeo

      - name: Login crane to Harbor
        run: |
          set -eo pipefail
          crane auth login "$REGISTRY" \
            -u "${{ secrets.OSG_HARBOR_ROBOT_USER }}" \
            -p "${{ secrets.OSG_HARBOR_ROBOT_PASSWORD }}"

      - name: Login skopeo to Harbor
        run: |
          set -eo pipefail
          skopeo login "$REGISTRY" \
            -u "${{ secrets.OSG_HARBOR_ROBOT_USER }}" \
            -p "${{ secrets.OSG_HARBOR_ROBOT_PASSWORD }}"

      - name: Login docker to Harbor
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.OSG_HARBOR_ROBOT_USER }}
          password: ${{ secrets.OSG_HARBOR_ROBOT_PASSWORD }}

      - name: Prepare tag list and validate
        id: prep
        env:
          SOURCE_TAG: ${{ github.event.inputs.source_tag }}
          TARGET_TAG: ${{ github.event.inputs.target_tag }}
          ADDITIONAL_TAGS_RAW: ${{ github.event.inputs.additional_tags }}
        run: |
          set -eo pipefail
          normalize_list () {
            echo "$1" | tr ',\n' '  ' | xargs -n1 echo | sed '/^$/d'
          }
          TARGETS="$(normalize_list "$TARGET_TAG")"
          if [ -n "$ADDITIONAL_TAGS_RAW" ]; then
            EXTRA="$(normalize_list "$ADDITIONAL_TAGS_RAW")"
            TARGETS="$(printf "%s\n%s\n" "$TARGETS" "$EXTRA" | sed '/^$/d')"
          fi
          echo "All target tags:"
          echo "$TARGETS"
          TAG_REGEX='^[A-Za-z0-9_.-]+$'
          echo "$SOURCE_TAG" | grep -Eq "$TAG_REGEX" || { echo "Invalid source tag '$SOURCE_TAG'"; exit 1; }
          while IFS= read -r t; do
            echo "$t" | grep -Eq "$TAG_REGEX" || { echo "Invalid target tag '$t'"; exit 1; }
          done <<<"$TARGETS"
          echo "targets<<EOF" >> "$GITHUB_OUTPUT"
          printf "%s\n" "$TARGETS" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Preflight classify source and registry health
        id: classify
        env:
          REPO: ${{ env.REGISTRY }}/${{ env.IMAGE_REPO }}
          SOURCE_TAG: ${{ github.event.inputs.source_tag }}
          HARBOR_USER: ${{ secrets.OSG_HARBOR_ROBOT_USER }}
          HARBOR_PASS: ${{ secrets.OSG_HARBOR_ROBOT_PASSWORD }}
        run: |
          set -eo pipefail
          set +x

          repo="${REPO}"
          tag="${SOURCE_TAG}"
          manifest_url="https://${repo}/manifests/${tag}"
          v2_url="https://${{ env.REGISTRY }}/v2/"
          accept_hdr="application/vnd.docker.distribution.manifest.list.v2+json, application/vnd.oci.image.index.v1+json, application/vnd.docker.distribution.manifest.v2+json, application/vnd.oci.image.manifest.v1+json"

          echo "Checking /v2/ registry endpoint"
          v2_code="$(curl -sS -o /dev/null -w "%{http_code}" "${v2_url}")" || v2_code="000"
          echo "Registry /v2/ HTTP code: ${v2_code}"

          echo "Probing WWW-Authenticate challenge for source manifest"
          wa_hdr="$(curl -sSI "https://${repo}/manifests/${tag}" | tr -d '\r' | grep -i '^WWW-Authenticate:' || true)"
          if [ -z "$wa_hdr" ]; then
            echo "No WWW-Authenticate header found; will rely on crane for source probing."
            echo "proceed=yes" >> "$GITHUB_OUTPUT"
            echo "registry_health_code=${v2_code}" >> "$GITHUB_OUTPUT"
            echo "source_status_class=unknown" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          parse_param () { echo "$wa_hdr" | sed -n "s/.*$1=\"\\([^\"]*\\)\".*/\\1/p"; }
          realm="$(parse_param realm)"
          service="$(parse_param service)"
          scope="repository:${repo#${{ env.REGISTRY }}/}:pull"

          if [ -z "$realm" ] || [ -z "$service" ]; then
            echo "Could not parse auth challenge; proceeding without classification."
            echo "proceed=yes" >> "$GITHUB_OUTPUT"
            echo "registry_health_code=${v2_code}" >> "$GITHUB_OUTPUT"
            echo "source_status_class=unknown" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "Fetching Bearer token"
          token="$(curl -sS --user "${HARBOR_USER}:${HARBOR_PASS}" "${realm}?service=$(printf %s "$service" | sed 's/ /%20/g')&scope=$(printf %s "$scope" | sed 's/:/%3A/g')" | jq -r '.token // empty')"
          if [ -z "$token" ]; then
            echo "Failed to obtain Bearer token; classification cannot continue."
            echo "proceed=no" >> "$GITHUB_OUTPUT"
            echo "source_status_class=auth_error" >> "$GITHUB_OUTPUT"
            exit 1
          fi

          echo "HEAD source manifest with Authorization and Accept"
          src_code="$(curl -sS -o /dev/null -w "%{http_code}" \
            -H "Authorization: Bearer ${token}" \
            -H "Accept: ${accept_hdr}" \
            "${manifest_url}")" || src_code="000"
          echo "Source manifest HTTP code: ${src_code}"

          class="unknown"
          case "${src_code}" in
            200|301|302|307) class="ok" ;;
            401|403) class="auth_error" ;;
            404) class="not_found" ;;
            429) class="rate_limited" ;;
            5*) class="server_error" ;;
            000) class="network_error" ;;
            *) class="other" ;;
          esac
          echo "source_status_class=${class}" >> "$GITHUB_OUTPUT"
          echo "registry_health_code=${v2_code}" >> "$GITHUB_OUTPUT"

          if [ "${class}" = "not_found" ]; then
            echo "ERROR: Source tag not found on registry. Failing fast."
            exit 1
          fi
          if [ "${class}" = "auth_error" ]; then
            echo "ERROR: Authentication/authorization problem. Failing fast."
            exit 1
          fi

          echo "proceed=yes" >> "$GITHUB_OUTPUT"

      - name: Promote tags with retry and fallbacks
        if: steps.classify.outputs.proceed == 'yes'
        env:
          SRC_REF: ${{ env.REGISTRY }}/${{ env.IMAGE_REPO }}:${{ github.event.inputs.source_tag }}
          TARGET_LIST: ${{ steps.prep.outputs.targets }}
          DRY_RUN: ${{ github.event.inputs.dry_run }}
          MAX_RETRIES: ${{ github.event.inputs.max_retries }}
        run: |
          set -eo pipefail
          echo "Promoting from: $SRC_REF"
          SUCCESS=0
          FAILED=0

          try_crane_copy () {
            local src="$1"; local dst="$2"; local max_attempts="$3"
            local attempts=0
            while true; do
              if crane copy "$src" "$dst"; then
                echo "crane copy succeeded -> $dst"
                return 0
              fi
              attempts=$((attempts+1))
              if [ "$attempts" -ge "$max_attempts" ]; then
                echo "crane copy failed after $attempts attempts -> $dst"
                return 1
              fi
              local sleep_sec=$((2 ** attempts))
              echo "crane copy retry $attempts/$max_attempts in ${sleep_sec}s ..."
              sleep "$sleep_sec"
            done
          }

          try_skopeo_copy () {
            local src="$1"; local dst="$2"
            skopeo copy --all "docker://${src}" "docker://${dst}"
          }

          try_docker_tag_push () {
            local src="$1"; local dst="$2"
            docker pull "$src"
            docker tag "$src" "$dst"
            docker push "$dst"
          }

          while IFS= read -r TGT; do
            [ -z "$TGT" ] && continue
            DST_REF="${REGISTRY}/${IMAGE_REPO}:${TGT}"
            echo "----"
            echo "Target: $DST_REF"
            if [ "$DRY_RUN" = "true" ]; then
              echo "(dry-run) Would promote $SRC_REF -> $DST_REF"
              SUCCESS=$((SUCCESS+1))
              continue
            fi

            if try_crane_copy "$SRC_REF" "$DST_REF" "${MAX_RETRIES:-5}"; then
              SUCCESS=$((SUCCESS+1))
              continue
            fi

            echo "Attempting skopeo copy fallback -> $DST_REF"
            if try_skopeo_copy "$SRC_REF" "$DST_REF"; then
              SUCCESS=$((SUCCESS+1))
              continue
            fi

            echo "Attempting docker tag/push fallback -> $DST_REF"
            if try_docker_tag_push "$SRC_REF" "$DST_REF"; then
              SUCCESS=$((SUCCESS+1))
              continue
            fi

            echo "ERROR: All promotion methods failed for $DST_REF" >&2
            FAILED=$((FAILED+1))
          done <<<"$TARGET_LIST"

          echo "----"
          echo "Promotion summary: success=$SUCCESS failed=$FAILED"
          [ $FAILED -eq 0 ] || { echo "Some promotions failed."; exit 1; }

      - name: Verify promoted tags
        if: ${{ github.event.inputs.dry_run == 'false' && steps.classify.outputs.proceed == 'yes' }}
        env:
          SRC_REF: ${{ env.REGISTRY }}/${{ env.IMAGE_REPO }}:${{ github.event.inputs.source_tag }}
          TARGET_LIST: ${{ steps.prep.outputs.targets }}
        run: |
          set -eo pipefail
          SRC_DIGEST=$(crane digest "$SRC_REF")
          echo "Source digest: $SRC_DIGEST"
          while IFS= read -r TGT; do
            [ -z "$TGT" ] && continue
            DST_REF="${REGISTRY}/${IMAGE_REPO}:${TGT}"
            DST_DIGEST=$(crane digest "$DST_REF" 2>/dev/null || true)
            if [ -z "$DST_DIGEST" ]; then
              echo "ERROR: Promoted tag missing: $DST_REF" >&2
              exit 1
            fi
            MATCH="no"
            [ "$DST_DIGEST" = "$SRC_DIGEST" ] && MATCH="yes"
            echo "Tag: $TGT  Digest: $DST_DIGEST  MatchSource: $MATCH"
          done <<<"$TARGET_LIST"

      - name: Summary
        run: |
          echo "Promotion complete."
          echo "Source: ${{ github.event.inputs.source_tag }}"
          echo "Primary target: ${{ github.event.inputs.target_tag }}"
          echo "Additional targets: ${{ github.event.inputs.additional_tags }}"
          echo "Dry run: ${{ github.event.inputs.dry_run }}"
